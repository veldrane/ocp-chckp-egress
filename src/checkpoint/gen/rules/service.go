// Code generated by goa v3.7.2, DO NOT EDIT.
//
// rules service
//
// Command:
// $ goa gen checkpoint/design

package rules

import (
	rulesviews "checkpoint/gen/rules/views"
	"context"

	goa "goa.design/goa/v3/pkg"
)

// Service provides management for stored chekcpoint rules
type Service interface {
	// List all egress rules
	EgressList(context.Context) (res *StoredCheckpointRuleSet, err error)
	// List all ingress rules
	IngressList(context.Context) (res *StoredCheckpointRuleSet, err error)
}

// ServiceName is the name of the service as defined in the design. This is the
// same value that is set in the endpoint request contexts under the ServiceKey
// key.
const ServiceName = "rules"

// MethodNames lists the service method names as defined in the design. These
// are the same values that are set in the endpoint request contexts under the
// MethodKey key.
var MethodNames = [2]string{"egressList", "ingressList"}

// A StoredCheckpointRules describes a one rules
type StoredCheckpointRule struct {
	// Return the name of the record
	Name string
	// uuid of the object
	ID string
	// description of the object
	Description string
	// Ip adresss
	Ranges []string
}

// StoredCheckpointRuleSet is the result type of the rules service egressList
// method.
type StoredCheckpointRuleSet struct {
	// version of the ruleset
	Version string
	// description of the object
	Description string
	// Rulesets
	Objects []*StoredCheckpointRule
}

// MakeNotFound builds a goa.ServiceError from an error.
func MakeNotFound(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "NotFound",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeMissingItem builds a goa.ServiceError from an error.
func MakeMissingItem(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "MissingItem",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeTimeout builds a goa.ServiceError from an error.
func MakeTimeout(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "Timeout",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeInternalError builds a goa.ServiceError from an error.
func MakeInternalError(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "InternalError",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// NewStoredCheckpointRuleSet initializes result type StoredCheckpointRuleSet
// from viewed result type StoredCheckpointRuleSet.
func NewStoredCheckpointRuleSet(vres *rulesviews.StoredCheckpointRuleSet) *StoredCheckpointRuleSet {
	return newStoredCheckpointRuleSet(vres.Projected)
}

// NewViewedStoredCheckpointRuleSet initializes viewed result type
// StoredCheckpointRuleSet from result type StoredCheckpointRuleSet using the
// given view.
func NewViewedStoredCheckpointRuleSet(res *StoredCheckpointRuleSet, view string) *rulesviews.StoredCheckpointRuleSet {
	p := newStoredCheckpointRuleSetView(res)
	return &rulesviews.StoredCheckpointRuleSet{Projected: p, View: "default"}
}

// newStoredCheckpointRuleSet converts projected type StoredCheckpointRuleSet
// to service type StoredCheckpointRuleSet.
func newStoredCheckpointRuleSet(vres *rulesviews.StoredCheckpointRuleSetView) *StoredCheckpointRuleSet {
	res := &StoredCheckpointRuleSet{}
	if vres.Version != nil {
		res.Version = *vres.Version
	}
	if vres.Description != nil {
		res.Description = *vres.Description
	}
	if vres.Version == nil {
		res.Version = "1.0"
	}
	if vres.Description == nil {
		res.Description = ""
	}
	if vres.Objects != nil {
		res.Objects = make([]*StoredCheckpointRule, len(vres.Objects))
		for i, val := range vres.Objects {
			res.Objects[i] = transformRulesviewsStoredCheckpointRuleViewToStoredCheckpointRule(val)
		}
	}
	return res
}

// newStoredCheckpointRuleSetView projects result type StoredCheckpointRuleSet
// to projected type StoredCheckpointRuleSetView using the "default" view.
func newStoredCheckpointRuleSetView(res *StoredCheckpointRuleSet) *rulesviews.StoredCheckpointRuleSetView {
	vres := &rulesviews.StoredCheckpointRuleSetView{
		Version:     &res.Version,
		Description: &res.Description,
	}
	if res.Objects != nil {
		vres.Objects = make([]*rulesviews.StoredCheckpointRuleView, len(res.Objects))
		for i, val := range res.Objects {
			vres.Objects[i] = transformStoredCheckpointRuleToRulesviewsStoredCheckpointRuleView(val)
		}
	}
	return vres
}

// newStoredCheckpointRule converts projected type StoredCheckpointRule to
// service type StoredCheckpointRule.
func newStoredCheckpointRule(vres *rulesviews.StoredCheckpointRuleView) *StoredCheckpointRule {
	res := &StoredCheckpointRule{}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Description != nil {
		res.Description = *vres.Description
	}
	if vres.Name == nil {
		res.Name = "generic-object"
	}
	if vres.ID == nil {
		res.ID = ""
	}
	if vres.Description == nil {
		res.Description = ""
	}
	if vres.Ranges != nil {
		res.Ranges = make([]string, len(vres.Ranges))
		for i, val := range vres.Ranges {
			res.Ranges[i] = val
		}
	}
	return res
}

// newStoredCheckpointRuleView projects result type StoredCheckpointRule to
// projected type StoredCheckpointRuleView using the "default" view.
func newStoredCheckpointRuleView(res *StoredCheckpointRule) *rulesviews.StoredCheckpointRuleView {
	vres := &rulesviews.StoredCheckpointRuleView{
		Name:        &res.Name,
		ID:          &res.ID,
		Description: &res.Description,
	}
	if res.Ranges != nil {
		vres.Ranges = make([]string, len(res.Ranges))
		for i, val := range res.Ranges {
			vres.Ranges[i] = val
		}
	}
	return vres
}

// transformRulesviewsStoredCheckpointRuleViewToStoredCheckpointRule builds a
// value of type *StoredCheckpointRule from a value of type
// *rulesviews.StoredCheckpointRuleView.
func transformRulesviewsStoredCheckpointRuleViewToStoredCheckpointRule(v *rulesviews.StoredCheckpointRuleView) *StoredCheckpointRule {
	if v == nil {
		return nil
	}
	res := &StoredCheckpointRule{}
	if v.Name != nil {
		res.Name = *v.Name
	}
	if v.ID != nil {
		res.ID = *v.ID
	}
	if v.Description != nil {
		res.Description = *v.Description
	}
	if v.Name == nil {
		res.Name = "generic-object"
	}
	if v.ID == nil {
		res.ID = ""
	}
	if v.Description == nil {
		res.Description = ""
	}
	if v.Ranges != nil {
		res.Ranges = make([]string, len(v.Ranges))
		for i, val := range v.Ranges {
			res.Ranges[i] = val
		}
	}

	return res
}

// transformStoredCheckpointRuleToRulesviewsStoredCheckpointRuleView builds a
// value of type *rulesviews.StoredCheckpointRuleView from a value of type
// *StoredCheckpointRule.
func transformStoredCheckpointRuleToRulesviewsStoredCheckpointRuleView(v *StoredCheckpointRule) *rulesviews.StoredCheckpointRuleView {
	if v == nil {
		return nil
	}
	res := &rulesviews.StoredCheckpointRuleView{
		Name:        &v.Name,
		ID:          &v.ID,
		Description: &v.Description,
	}
	if v.Ranges != nil {
		res.Ranges = make([]string, len(v.Ranges))
		for i, val := range v.Ranges {
			res.Ranges[i] = val
		}
	}

	return res
}
