// Code generated by goa v3.7.2, DO NOT EDIT.
//
// rules HTTP server encoders and decoders
//
// Command:
// $ goa gen checkpoint/design

package server

import (
	rulesviews "checkpoint/gen/rules/views"
	"context"
	"net/http"

	goahttp "goa.design/goa/v3/http"
)

// EncodeEgressListResponse returns an encoder for responses returned by the
// rules egressList endpoint.
func EncodeEgressListResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(*rulesviews.StoredCheckpointRuleSet)
		enc := encoder(ctx, w)
		body := NewEgressListResponseBody(res.Projected)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// EncodeIngressListResponse returns an encoder for responses returned by the
// rules ingressList endpoint.
func EncodeIngressListResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(*rulesviews.StoredCheckpointRuleSet)
		enc := encoder(ctx, w)
		body := NewIngressListResponseBody(res.Projected)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// marshalRulesviewsStoredCheckpointRuleViewToStoredCheckpointRuleResponseBody
// builds a value of type *StoredCheckpointRuleResponseBody from a value of
// type *rulesviews.StoredCheckpointRuleView.
func marshalRulesviewsStoredCheckpointRuleViewToStoredCheckpointRuleResponseBody(v *rulesviews.StoredCheckpointRuleView) *StoredCheckpointRuleResponseBody {
	if v == nil {
		return nil
	}
	res := &StoredCheckpointRuleResponseBody{}
	if v.Name != nil {
		res.Name = *v.Name
	}
	if v.ID != nil {
		res.ID = *v.ID
	}
	if v.Description != nil {
		res.Description = *v.Description
	}
	if v.Name == nil {
		res.Name = "generic-object"
	}
	if v.ID == nil {
		res.ID = ""
	}
	if v.Description == nil {
		res.Description = ""
	}
	if v.Ranges != nil {
		res.Ranges = make([]string, len(v.Ranges))
		for i, val := range v.Ranges {
			res.Ranges[i] = val
		}
	}

	return res
}
